/*
 * node.h
 *
 *  Created on: 23. 7. 2022
 *      Author: ondra
 */

#ifndef LIB_UMQ_NODE_H_32130djwoeijd08923jdeioew
#define LIB_UMQ_NODE_H_32130djwoeijd08923jdeioew

#include "peer.h"
#include "message.h"
#include "connection.h"
#include "methodlist.h"
#include "payload.h"
#include <shared/callback.h>
#include <shared/svo_vector.h>
#include <shared/toString.h>
#include <algorithm>
#include <deque>
#include <map>
#include <memory>
#include <shared_mutex>
#include <any>
#include <queue>

namespace umq {

#ifndef UMQ_MESSAGE_BUILDER_STACK_ALLOC
#define UMQ_MESSAGE_BUILDER_STACK_ALLOC 256
#endif

enum class PeerError {
    noError = 0,
    unexpectedBinaryFrame=1,
    messageParseError=2,
    unknownMessageType=3,
    messageProcessingError=4,
    unsupportedVersion=5,
    unhandledException=6,
    methodNotFound=7,
    callbackIsNotRegistered=8
};

///Defines behavior for high water mark signal
enum class HighWaterMarkBehavior{
    ///skip topic update (this is default)
    skip,
    ///block call until HWM is dropped
    block,
    ///ignore HWM, enqueue the update to increasing buffer
    ignore,
    ///unsubscribe the topic
    unsubscribe,
    ///close the connection
    close
};

enum class PeerMsgType: char {
    ///Execution error
    /** ?id msg - exception during processing request (not exception generated by method) */
    execution_error = '!',

    ///Discover request
    /** ?id params - discovers supported services of the peer (same as call) */
    discover = '?',

	///Attachment error
	/**#<error message> - counted as attachment, but contians an error
	 */
	attachmentError = '#',

	attachment = 'A',

    ///Callback
    /** Cid args - request to callback method - response is R or E (or ?) */
    callback = 'C',

    ///Exception caused by a method (C or M)
    /** Eid msg - contains exception message     */
    exception = 'E',

    ///Hello message - send by connecting peer to initialize connection,
    /**Hversion data */
    hello = 'H',

    ///Method call - send request - response is R or E (or ?) */
    /** Mid method_name args */
    method_call = 'M',

    ///Result of successful call
    /** Rid data */
    result = 'R',

    ///Sets value on the other side
    /** Svar value */
    var_set = 'S',

    ///Update of a topic
    /** Ttopic data */
    topic_update = 'T',

    ///Unsubscribe the topic
    /** Utopic */
    unsubscribe = 'U',

    ///Welcome message - sent by server as response to hello message
    /** Wversion data */
    welcome = 'W',

    ///Unset the variabl
    /** Xvar */
    var_unset = 'X',

    ///Close the topic - sent by publisher information to subscriber that topic has been closed
    /** Ztopic */
    topic_close = 'Z'
};


///Called in client when welcome request arrived. From this point, node is ready
using WelcomeResponse = ondra_shared::Callback<void(const Payload &)>;
///Called on server when hello request arrived, can return response. From this point, node is ready
using HelloRequest = ondra_shared::Callback<void(const Payload &, WelcomeResponse &&)>;
///Called to unsubscribe topic by subscriber
using UnsubscribeRequest = ondra_shared::Callback<void()>;
///called when node disconnects, before it is destroyed
using DisconnectEvent = ondra_shared::Callback<void()>;

using BinaryContentEvent = ondra_shared::Callback<void(bool valid, const std::string_view &content)>;

using SharedVariables = std::map<std::string, PayloadStr, std::less<> >;

using PeerVariables = std::map<std::string, std::any, std::less<> >;

template<typename T> struct NullCmp { bool operator()(const T &a, const T &b)const {return false;} };


using DiscoverCallback = ondra_shared::Callback<void(DiscoverResponse &)>;

class Peer: public std::enable_shared_from_this<Peer>{
public:

    using PConnection = std::unique_ptr<AbstractConnection>;


    ~Peer();


    static PPeer make();

    ///Called on disconnect to handle extra cleanup or try to reconnect
    /**
     * You should set this handler before the peer is initialized. For
     * client peers (this is server), you can use keep_until_disconnected which
     * heavily uses weak pointers (PWkPeer) to hold reference to the
     * peer's instance without allowing it to release on disconnect.
     *
     * @param disconnect function called when peer is disconnected
     *
     * @note once the peer is disconnected, there is no way to reconnect
     * it back again. It is better to estabilish a new connection with
     * a new Peer instance.
     */
    void on_disconnect(DisconnectEvent &&disconnect);

    ///Keeps peer object referenced until it is disconnected
    /** this allows to have object initialized and active
     * until it is disconnected. Function is implemented as on_disconnect()
     * so it resets current disconnect handler.
     */
    void keep_until_disconnected();
    ///Init server.
    /**
     * The server is side, which accepted connection. This must be called by acceptor.
     * It can also initialize object before it is ready to accept connection. Once
     * servere is initialized, it starts to process messages
     *
     * @param conn connection (created by listening and accepting incoming connection)
     * @param resp handler, which process initial message exchange Hello-Welcome.
     * Once the Hello arrives, initialization is ready. Do not send messages until
     * the initialization is complete.
     */
    void init_server(PConnection &&conn, HelloRequest &&resp);

    ///Initialize client
    /**
     * The client is side, which created connection by connecting a server.
     * @param conn connection (created using connect)
     * @param req request data sent with Hello request.
     * @param resp callback called when Welcome message arrives
     *
     * You can start use the node after Welcome arrives, never soon.
     */
    void init_client(PConnection &&conn,const Payload &req,  WelcomeResponse &&resp);


    ///Discover services of the peer
    /**
     * @param query discover query. Can be either empty, or contain name of method,
     *   name of proxy to discover.
     * @param cb function called when result arrives
     */
    void discover(const std::string_view &query, DiscoverCallback  &&cb);

    ///Perform RPC call
    /**
     *
     * @param method method
     * @param params parameters
     * @param result callback which handles result
     */
    void call(const std::string_view &method, const Payload &params, ResponseCallback &&result);

    ///Subscribes given topic
    /** Doesn't perform actual subscription, it only prepares
     * the peer object to receive a process given subscription. The actual
     * subscription is registered via a request. Other side must
     * respond with a topic, which must be registered immediately
     * while response is being processed. Topic can't be registered
     * later in asynchronous processing, because a message for this
     * topic could be already processed and without proper registration
     * it is rejected.
     *
     * @param topic topic to register
     * @param cb callback function called for the topic update
     */
    void subscribe(const std::string_view &topic, TopicUpdateCallback &&cb);


    ///Initiates publishing (implicit unsubscribe)
    /** Prepares node to publish.
     *
     * @param topic topic to be published
     * @param hwmb defines behaviour for high water mark signal.
     * @param hwm_size defines custom HWM size for this topic. Default 0 means to use value specified by set_hwm()
     *
     * @return function to call to publish the update for this node.
     *
     * @note unsubscribe is performed implicitly. When node unsubscribes,
     * the next call of the TopicUpdateCallback function returns false,
     * which causes, that function is removed from the topic. Note
     * that untill next call, the publisher has no information about
     * node unsubscribe, which can cause build up memory temporaryli (in
     * the case of sequence sub-unsub-sub-unsub...)
     */
    TopicUpdateCallback start_publish(const std::string_view &topic, HighWaterMarkBehavior hwmb = HighWaterMarkBehavior::skip, std::size_t hwm_size = 0);


    ///Specifies callback function when unsubscribe is requested
    /**
     * @param topic topic name
     * @param cb callback function called when remote node wants to unsubscribe
     * @retval true function registered
     * @retval false topic is not registered, already unsubscribed, or peer is down
     */
    bool on_unsubscribe(const std::string_view &topic, UnsubscribeRequest &&cb);


    ///Sets method list
    /**
     * Sets object responsible to mantain list of methods for the
     * rpc-server mode. Method list can be changed anytime, and
     * changes are propagated to the node.
     *
     * @param method_list pointer to method lis
     */
    void set_methods(const PMethodList &method_list);

    ///Register new callback
    /**
     * Callback is ad-hoc method, which can be called by other side. Function
     * return identifier, which must be passed to the other side. Once the other
     * side need to call the callback, it executes call_callback() which given id
     * and arguments. The callback can be called only once, method is then removed. If
     *  you need additional calls, you must register the callback again after each call (and
     *  send new ID to the caller)
     *
     * @param c Function which is called for the callback. Note that function is not
     * called if the peer is disconnected and destroyed.
     * @return Identifier of the callback
     */
    std::string reg_callback(MethodCall &&c);


    ///Unregisters callback
    /**
     * Unregisters the callback registered previously by reg_callback(). You can decide to
     * unregister callback which is no longer needed to release some memory. Note that
     * identifier is reserved forever, so if the callback is eventually called, an error
     * is returned to the caller
     *
     * @param id identifier of the callback to remove
     * @retval true callback removed
     * @retval false callback not found
     */
    bool unreg_callback(const std::string_view &id);

    ///Call a callback function
    /**
     * Generate request to call a callback function of the peer. The callback must be
     * registered at that peer. The callback is identified by an id, which is typically
     * transfered by other type of message
     *
     * @param id id of the callback function
     * @param args arguments
     * @param response function called once the response is available.
     * @retval true called
     * @retval false ID clash / conflict - if the IDs are generated, there should be no conflict
     *   however different client can generate conflicted ID's, and this error can happend
     *
     * @note ID for callbacks should have a suffix _cb while normal requests shouldn't
     */
    void call_callback(const std::string_view &id, const std::string_view &args, ResponseCallback &&response);




    ///Unsubscribe given topic
    /**
     * @param topic Explicitly unsubscribe the topic.
     *
     * @note You can unsubscribe implicitly by returning false from
     * the callback function. It is prefered way, which eliminates
     * race conditions
     */
    void unsubscribe(const std::string_view &topic);


    void set_hwm(std::size_t sz);

    std::size_t get_hwm() const;

    static std::size_t default_hwm;




    ///Determines, whether stream is still connected
    bool is_connected() const;



    ///Public interface to access variables
    template<typename T, typename Cmp>
    class VarSpace {
    public:
    	using Map = std::map<std::string, T, std::less<> >;
    	using UpdateFn = void (Peer::*)(const std::string_view &name, const std::optional<T> &value);

    	///Get value of the variable
    	/**
    	 * @param name name of the varuable
    	 * @return returns content of the variable as optional. You need to check
    	 * .has_value() to detemine whether the variable is defined
    	 */
    	std::optional<T> get(const std::string_view &name) const;

    	///Get all variables
    	Map get();

    	///Merge variables from the map - replacing existing ones
    	void merge(const Map &other);

    	///Replace whole map
    	void set(const Map &other);

    protected:
    	friend class Peer;
    	VarSpace(Peer &owner, UpdateFn upfn);
    	Peer &_owner;
    	UpdateFn _upfn;
    	std::shared_timed_mutex &lock() const;
    	Map _vars;

    	VarSpace(const VarSpace &other) = delete;
    	VarSpace &operator=(const VarSpace &other) = delete;
    	///Set value of the variable
    	/**
    	 * @param name name of variable
    	 * @param value a value as optional. If you use the optional without a
    	 * value, result is in deletion of the variable, otherwise, the
    	 * value is set or replaced
    	 */
    	void set(const std::string_view &name, const std::optional<T> &value);
    };

    template<typename T, typename Cmp>
    class VarSpaceRW: public VarSpace<T,Cmp> {
    public:
    	using VarSpace<T,Cmp>::VarSpace;
    	using VarSpace<T,Cmp>::set;
    };

    VarSpace<std::string, std::equal_to<std::string> > remote;
    VarSpaceRW<std::string, std::equal_to<std::string> > local;
    VarSpaceRW<std::any, NullCmp<std::any> > context;


protected:

    using MsgBld = ondra_shared::Vector<char, UMQ_MESSAGE_BUILDER_STACK_ALLOC>;

    Peer();

    friend class Request;
	void on_result(const std::string_view &id, const Payload &data);
	void on_welcome(const std::string_view &version, const Payload &data);
	void on_exception(const std::string_view &id, const Payload &data);
	void on_topic_close(const std::string_view &topic_id);
	void on_hello(const std::string_view &version, const Payload &data);
	void on_unsubscribe(const std::string_view &topic_id);
	bool on_topic_update(const std::string_view &topic_id, const Payload &data);
	bool on_method_call(const std::string_view &id, const std::string_view &method, const Payload &args);
    bool on_callback(const std::string_view &id, const std::string_view &name, const Payload &args);
	void on_execute_error(const std::string_view &id, const Payload &msg);
	bool on_binary_message(const umq::MessageRef &msg);
	bool on_attachment_error(const std::string_view &msg);
	void on_set_var(const std::string_view &variable, const std::string_view &data);
	void on_unset_var(const std::string_view &variable);
    bool on_discover(const std::string_view &id, const std::string_view &query);

    ///Parse message from connection
    void parse_message(const MessageRef &msg);

    void parse_text_message(std::string_view data, AttachList &&alist);

    ///Sends topic update
    /**
     * @param topic_id topic id
     * @param data data of topic
     * @retval true topic update sent
     * @retval false other side unsubscribed this topic
     *
     * @note default implementation always returns true. Extending class can implement own logic
     *
     */
    bool send_topic_update(const std::string_view &topic_id, const Payload &data, HighWaterMarkBehavior hwmb, std::size_t hwm_size );

    ///Close the topic
    /**
     * Sent by publisher about the topic is closed
     * @param topic_id topic id
     */
    void send_topic_close(const std::string_view &topic_id);

    ///Unsubscribe the topic
    /**
     * Sent by subscriber to prevent sending updates on given topic
     * @param topic_id
     */
    void send_unsubscribe(const std::string_view &topic_id);

    ///Sends result of RPC call
    /**
     * @param id id of request
     * @param data data of request
     *
     *
     */
    void send_result(const std::string_view &id, const Payload &data);

    ///Sends exception of RPC call
    /**
     * @param id id of request
     * @param data data of request
     */
    void send_exception(const std::string_view &id, const Payload &data);

    void send_exception(const std::string_view &id, int code, const std::string_view &message);

    void send_exception(const std::string_view &id, PeerError code, const std::string_view &message);

    ///Sends about unknown method
    /**
     * @param id id of request
     * @param method_name method name
     */
    void send_execute_error(const std::string_view &id, const Payload &msg);

    void send_execute_error(const std::string_view &id, PeerError code);

    ///Sends welcome
    /**
     * @param version version (1.0,0)
     * @param data arbitrary data
     */
    void send_welcome(const std::string_view &version, const Payload &data);

    ///Sends hello
    /**
     * @param version version (1.0,0)
     * @param data arbitrary data
     */
    void send_hello(const std::string_view &version, const Payload &data);

    ///Sets remote variable
    /**
     * @param variable variable
     * @param data data of variable - use 'undefined' to unset variable
     */
    void send_var_set(const std::string_view &variable, const std::string_view &data);


    void send_var_unset(const std::string_view &variable);

    void send_call(const std::string_view &id, const std::string_view &method, const Payload &params);

    void send_callback_call(const std::string_view &id, const std::string_view &method, const Payload &args);

    static const char *error_to_string(PeerError err);

    void send_message(const MessageRef &msg);

    void send_discover(const std::string_view &id, const std::string_view &method_name);

    void send_message(PeerMsgType msgType, const std::string_view &id);

    template<typename MiddlePart>
    void build_send_message(PeerMsgType msgType, const std::string_view &id, MiddlePart &&fn, const Payload &payload);
    void run_upload();

    void send_message(PeerMsgType msgType, const std::string_view &id, const Payload &payload);
    void send_message(PeerMsgType msgType, const std::string_view &id, const std::string_view &cmd, const Payload &payload);



protected:

    class Listener: public AbstractConnectionListener {
    public:
        explicit Listener(Peer &owner);
        Listener(const Listener &) = delete;
        Listener &operator=(const Listener &) = delete;
        virtual void on_close() override;
        virtual void on_message(const umq::MessageRef &msg) override;
    protected:
        Peer &_owner;
    };

    std::unique_ptr<AbstractConnection> _conn;
    Listener _listener;

    static std::string_view version;

    using Topics = std::map<std::string, UnsubscribeRequest, std::less<> >;
    using Subscriptions = std::map<std::string, TopicUpdateCallback, std::less<> >;
    using CallMap = std::map<std::string, ResponseCallback, std::less<> >;
    using CallbackMap = std::map<std::string, MethodCall, std::less<> >;


    PMethodList _methods;
    Topics _topic_map;
    Subscriptions _subscr_map;
    CallMap _call_map;
    CallbackMap _cb_map;

    HelloRequest _hello_cb;
    WelcomeResponse _welcome_cb;
    DisconnectEvent _discnt_cb;
    std::size_t _hwm;

    mutable std::shared_timed_mutex _lock;
    unsigned int _call_id = 0;

    std::queue<Attachment> _dwnl_attachments;
    std::queue<Attachment> _upld_attachments;



    void finish_call(const std::string_view &id, Response &&response);



    void send_node_error(PeerError error);


    void listener_fn(const std::optional<MessageRef> &msg);
    void disconnect();
    void syncVar(const std::string_view &var, const std::optional<std::string> &value);

};

inline void Peer::send_message(PeerMsgType msgType, const std::string_view &id) {
	MsgBld bld;
	bld.push_back(static_cast<char>(msgType));
	bld.append(id.begin(), id.end());
	send_message(MessageRef{MessageType::text, std::string_view(bld.data(),bld.size())});
}

template<typename MiddlePart>
inline void Peer::build_send_message(PeerMsgType msgType, const std::string_view &id,
		MiddlePart &&fn, const Payload &payload) {
	MsgBld bld;
	if (!payload.attachments.empty()) {
		bld.push_back(static_cast<char>(PeerMsgType::attachment));
		ondra_shared::unsignedToString(payload.attachments.size(), [&](char c){
			bld.push_back(c);
		},10,1);
		bld.push_back('\n');
	}
	bld.push_back(static_cast<char>(msgType));
	bld.append(id.begin(), id.end());
	bld.push_back('\n');
	fn(bld);
	bld.append(payload.begin(), payload.end());
	if (payload.attachments.empty()) {
		send_message(MessageRef{MessageType::text, std::string_view(bld.data(),bld.size())});
	} else {
		std::lock_guard _(_lock);
		bool need_start = _upld_attachments.empty();
		for (const auto &x: payload.attachments) {
			_upld_attachments.push(x);
		}
		send_message(MessageRef{MessageType::text, std::string_view(bld.data(),bld.size())});
		if (need_start) run_upload();
	}
}

inline void Peer::send_message(PeerMsgType msgType, const std::string_view &id,
		const Payload &payload) {
	build_send_message(msgType, id, [](MsgBld &){}, payload);
}

inline void Peer::send_message(PeerMsgType msgType, const std::string_view &id,
		const std::string_view &cmd,
		const Payload &payload) {
	build_send_message(msgType, id, [&](MsgBld &bld){
		bld.append(cmd.begin(),cmd.end());
		bld.push_back('\n');
	}, payload);
}


}


#endif /* LIB_UMQ_NODE_H_32130djwoeijd08923jdeioew */
